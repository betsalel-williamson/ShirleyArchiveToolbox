--- ./run.py ---
#! python run.py
from validator_app import create_app

app = create_app()

if __name__ == "__main__":
    # The debug flag will be read from the config
    app.run()

--- ./requirements.txt ---
Flask
Pillow

--- ./validator_app/config.py ---
# validator_app/config.py
import os

class Config:
    """Base configuration."""
    SECRET_KEY = os.environ.get('SECRET_KEY', 'a_very_secret_key')

    # Directory paths
    SOURCE_DATA_DIR = 'data_source'
    IN_PROGRESS_DATA_DIR = 'data_in_progress'
    VALIDATED_DATA_DIR = 'data_validated'
    IMAGE_DIR = os.path.join('static', 'images')

    # Flask app settings
    DEBUG = True

--- ./validator_app/__init__.py ---
# validator_app/__init__.py
import os
from flask import Flask


def create_app():
    """Create and configure an instance of the Flask application."""
    app = Flask(__name__, instance_relative_config=True)

    # Load configuration from config.py
    app.config.from_object("validator_app.config.Config")

    # Ensure data directories exist
    with app.app_context():
        os.makedirs(app.config["SOURCE_DATA_DIR"], exist_ok=True)
        os.makedirs(app.config["IN_PROGRESS_DATA_DIR"], exist_ok=True)
        os.makedirs(app.config["VALIDATED_DATA_DIR"], exist_ok=True)

    # Register Blueprints
    from .routes.main import main_bp

    app.register_blueprint(main_bp)

    from .routes.api import api_bp

    app.register_blueprint(api_bp)

    return app

--- ./validator_app/utils.py ---
# validator_app/utils.py
import os
import json
import math
from flask import current_app


def get_json_files():
    """Get a sorted list of all unique JSON files from all data directories."""
    config = current_app.config
    files = set(os.listdir(config["SOURCE_DATA_DIR"]))
    files.update(os.listdir(config["IN_PROGRESS_DATA_DIR"]))
    files.update(os.listdir(config["VALIDATED_DATA_DIR"]))
    return sorted([f for f in files if f.endswith(".json")])


def get_file_status(json_filename):
    """Check the status of a file: 'validated', 'in_progress', or 'source'."""
    config = current_app.config
    if os.path.exists(os.path.join(config["VALIDATED_DATA_DIR"], json_filename)):
        return "validated"
    if os.path.exists(os.path.join(config["IN_PROGRESS_DATA_DIR"], json_filename)):
        return "in_progress"
    return "source"


def load_data(json_filename):
    """Load data with 3-tier priority: In Progress > Validated > Source."""
    config = current_app.config
    in_progress_path = os.path.join(config["IN_PROGRESS_DATA_DIR"], json_filename)
    validated_path = os.path.join(config["VALIDATED_DATA_DIR"], json_filename)
    source_path = os.path.join(config["SOURCE_DATA_DIR"], json_filename)

    load_path = None
    if os.path.exists(in_progress_path):
        load_path = in_progress_path
    elif os.path.exists(validated_path):
        load_path = validated_path
    elif os.path.exists(source_path):
        load_path = source_path

    if not load_path:
        return None

    with open(load_path, "r") as f:
        return json.load(f)


def apply_transformations_to_data(form_data):
    """Helper to apply form changes to a data object."""
    data = json.loads(form_data["json_data"])
    offsetX = float(form_data.get("offsetX", 0))
    offsetY = float(form_data.get("offsetY", 0))
    rotation_deg = float(form_data.get("rotation", 0))
    scale = float(form_data.get("scale", 1.0))
    is_transformed = offsetX != 0 or offsetY != 0 or rotation_deg != 0 or scale != 1.0

    if is_transformed:
        img_dims = data.get("image_dimensions", {})
        cx = img_dims.get("width", 0) / 2
        cy = img_dims.get("height", 0) / 2
        rotation_rad = math.radians(rotation_deg)
        cos_rad = math.cos(rotation_rad)
        sin_rad = math.sin(rotation_rad)

    all_words = {
        word["id"]: word
        for line in data.get("lines", [])
        for word in line.get("words", [])
    }

    for key, value in form_data.items():
        if key.startswith("text_"):
            word_id = key.replace("text_", "")
            if word_id in all_words:
                all_words[word_id]["text"] = value

    if is_transformed:
        for word in all_words.values():
            if "bounding_box" not in word:
                continue
            bbox = word["bounding_box"]
            corners = [
                (bbox["x_min"], bbox["y_min"]),
                (bbox["x_max"], bbox["y_min"]),
                (bbox["x_max"], bbox["y_max"]),
                (bbox["x_min"], bbox["y_max"]),
            ]
            transformed_corners = []
            for x, y in corners:
                x_scaled = cx + (x - cx) * scale
                y_scaled = cy + (y - cy) * scale
                x_rot = cx + (x_scaled - cx) * cos_rad - (y_scaled - cy) * sin_rad
                y_rot = cy + (x_scaled - cx) * sin_rad + (y_scaled - cy) * cos_rad
                transformed_corners.append((x_rot + offsetX, y_rot + offsetY))

            word["bounding_box"] = {
                "x_min": int(round(min(p[0] for p in transformed_corners))),
                "y_min": int(round(min(p[1] for p in transformed_corners))),
                "x_max": int(round(max(p[0] for p in transformed_corners))),
                "y_max": int(round(max(p[1] for p in transformed_corners))),
            }
    return data

--- ./validator_app/static/css/style.css ---
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: #f4f4f9;
  color: #333;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgb(0 0 0 / 10%);
}

h1,
h2,
h3 {
  color: #0056b3;
}

/* Index Page */
ul {
  list-style-type: none;
  padding: 0;
}

li {
  padding: 10px;
  border-bottom: 1px solid #eee;
}

li a {
  text-decoration: none;
  color: #007bff;
  font-weight: bold;
}

li a:hover {
  text-decoration: underline;
}

.validated-check {
  color: #28a745;
  font-weight: bold;
  margin-left: 10px;
}

/* Validation Page */
.validation-container {
  display: flex;
  gap: 30px;
}

.image-pane {
  flex: 2;
}

.image-pane img {
  max-width: 100%;
  height: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.form-pane {
  flex: 1;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

.form-group input {
  width: 100%;
  padding: 8px;
  box-sizing: border-box;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.buttons {
  margin-top: 20px;
  display: flex;
  gap: 10px;
}

button {
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  color: white;
  background-color: #007bff;
  cursor: pointer;
  font-size: 16px;
}

button:hover {
  background-color: #0056b3;
}

.approve-btn {
  background-color: #28a745;
}

.approve-btn:hover {
  background-color: #218838;
}

.back-link {
  display: inline-block;
  margin-top: 20px;
}

/* Wrapper to position the image and the overlay together */

/* Find this existing rule... */
.image-wrapper {
  position: relative;
  /* This is crucial for positioning the overlay */
  display: inline-block;
  /* Shrink-wrap the container to the image size */
  overflow: hidden;
  /* ADD THIS LINE */
}

.image-wrapper img {
  display: block;
  /* Removes bottom space under the image */
}

/* The overlay that contains all boxes and is draggable */
#bbox-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  cursor: grab;
  /* Indicates this element is draggable */
}

#bbox-overlay.dragging {
  cursor: grabbing;
  /* Change cursor while dragging */
}

/* Individual bounding box style */
.bounding-box {
  position: absolute;
  box-sizing: border-box;
  /* Ensures border width is included in element's size */
  border: 2px solid red;
  background-color: rgb(255 0 0 / 10%);
  /* Slight red tint inside */
}

/* Label for each box */
.box-label {
  position: absolute;
  top: -16px;
  /* Position above the box */
  left: 0;
  background-color: red;
  color: white;
  font-size: 12px;
  padding: 1px 4px;
  border-radius: 3px;
  font-weight: bold;
}

/* --- NEW STYLES FOR TRANSFORMATION CONTROLS --- */
.controls {
  background-color: #f8f9fa;
  padding: 15px;
  border: 1px solid #dee2e6;
  border-radius: 5px;
  margin-bottom: 15px;
}

.control-group {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.control-group label {
  font-weight: bold;
  width: 60px;
}

.control-group input[type="range"] {
  flex-grow: 1;
}

.control-group input[type="number"] {
  width: 80px;
}

/* --- NEW STYLES FOR SCROLLABLE FORM PANE --- */

/* Make the body and html take up the full height of the browser window */
html,
body {
  height: 100%;
  margin: 0;
  padding: 0;
}

/* Adjust body to be a flex container to manage layout */
body {
  display: flex;
  flex-direction: column;
}

/* Make the main container expand to fill the available space */
.container.validation-container {
  flex-grow: 1;
  /* Allows the container to grow */
  display: flex;
  /* We are already using flex, but reaffirming */
  max-height: calc(100vh - 40px);
  /* Full viewport height minus body padding */
  padding: 20px;
  box-sizing: border-box;
}

/* Make the image pane scrollable if the image is too large */
.image-pane {
  overflow: auto;
  /* Allow scrolling if image/controls are too big */
  flex: 2;
  /* Keep its ratio */
}

/* This is the key change for the form pane */
.form-pane {
  flex: 1;
  /* Keep its ratio */
  display: flex;
  /* Use flexbox to manage its children (title + form) */
  flex-direction: column;
  /* Stack children vertically */
  height: 100%;
  /* Make it as tall as its parent container */
  overflow: hidden;
  /* Prevent the pane itself from scrolling */
}

.form-pane h3 {
  flex-shrink: 0;
  /* Prevent the title from shrinking */
}

/* Make the form element inside the pane the one that scrolls */
.form-pane form {
  flex-grow: 1;
  /* Allow the form to take up all remaining vertical space */
  overflow-y: auto;
  /* The magic! Enable vertical scrolling ONLY for the form */
  padding-right: 15px;
  /* Add some space for the scrollbar */
  margin-right: -15px;
  /* Counteract the padding to maintain alignment */
}

/* --- NEW STYLES FOR ACTION BUTTONS --- */
.control-group.action-buttons {
  margin-top: 15px;
  border-top: 1px solid #ddd;
  padding-top: 15px;
}

.secondary-btn {
  background-color: #6c757d;
  padding: 8px 12px;
  font-size: 14px;
}

.secondary-btn:hover {
  background-color: #5a6268;
}

.secondary-btn:disabled {
  background-color: #c0c4c8;
  cursor: not-allowed;
}

.danger-btn {
  background-color: #dc3545;
  padding: 8px 12px;
  font-size: 14px;
}

.danger-btn:hover {
  background-color: #c82333;
}

/* Add this rule to style the new translate inputs */
#translateX-input,
#translateY-input {
  width: 80px;
}
--- ./validator_app/templates/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Image Validation</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>

<body>
  <div class="container">
    <h1>Transcription Validation</h1>
    <p>Select a file to validate. Status will be shown.</p>
    <ul>
      {% for file in files %}
      <li>
        <a href="{{ url_for('main.validate', json_filename=file.filename) }}">
          {{ file.filename }}
        </a>
        {% if file.status == 'validated' %}
        <span class="status-validated">Validated ✓</span>
        {% elif file.status == 'in_progress' %}
        <span class="status-progress">In Progress...</span>
        {% endif %}
      </li>
      {% else %}
      <li>No JSON files found in any data directory.</li>
      {% endfor %}
    </ul>
  </div>
</body>

</html>
--- ./validator_app/templates/validate.html ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Validate {{ json_filename }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>

<body>
  <div class="container validation-container">
    <div class="image-pane">
      <h2>{{ image_filename }}</h2>

      <!-- NEW: Transformation Controls -->
      <div class="controls">
        <div class="control-group">
          <label for="rotate-slider">Rotate:</label>
          <input type="range" id="rotate-slider" min="-45" max="45" value="0" step="0.1">
          <input type="number" id="rotate-input" value="0" step="0.1"> °
        </div>
        <div class="control-group">
          <label for="scale-slider">Scale:</label>
          <input type="range" id="scale-slider" min="0.01" max="2.0" value="1.0" step="0.01">
          <input type="number" id="scale-input" value="1.0" step="0.01"> x
        </div>
        <!-- NEW: Translate controls -->
        <div class="control-group">
          <label for="translateX-input">Translate:</label>
          <input type="number" id="translateX-input" value="0" step="1" placeholder="X">
          <input type="number" id="translateY-input" value="0" step="1" placeholder="Y"> px
        </div>
        <!-- NEW: Undo/Redo/Revert Controls -->
        <div class="control-group action-buttons">
          <button id="undo-btn" class="secondary-btn" disabled>Undo</button>
          <button id="redo-btn" class="secondary-btn" disabled>Redo</button>
          <button id="revert-btn" class="danger-btn">Revert to Original</button>
        </div>
        <p>Then, click and drag the red boxes to align them.</p>
      </div>

      <div class="image-wrapper">
        <img src="{{ url_for('static', filename='images/' + image_filename) }}" alt="Base Image">
        <div id="bbox-overlay">
          {% for word in annotations %}
          {% set bbox = word.bounding_box %}
          <div class="bounding-box" style="left: {{ bbox.x_min }}px; top: {{ bbox.y_min }}px;
                                    width: {{ bbox.x_max - bbox.x_min }}px; height: {{ bbox.y_max - bbox.y_min }}px;">
            <span class="box-label">{{ word.display_id }}</span>
          </div>
          {% endfor %}
        </div>
      </div>
    </div>

    <div class="form-pane">
      <h3>
        Word Transcriptions
        <!-- NEW: Autosave status indicator -->
        <span id="autosave-status"></span>
      </h3>
      <!-- The form's action now points to the commit route -->
      <form id="main-form" action="{{ url_for('api.commit', json_filename=json_filename) }}" method="post">
        <!-- NEW: A hidden field to hold the ORIGINAL json data -->
        <textarea name="json_data" style="display:none;">{{ json_data_string }}</textarea>
        <!-- Hidden fields to store the final transformation state -->
        <input type="hidden" name="offsetX" id="offsetX" value="0">
        <input type="hidden" name="offsetY" id="offsetY" value="0">
        <input type="hidden" name="rotation" id="rotation" value="0">
        <input type="hidden" name="scale" id="scale" value="1.0">

        {% for word in annotations %}
        <div class="form-group">
          <label for="text_{{ word.id }}">Word {{ word.display_id }}:</label>
          <input type="text" id="text_{{ word.id }}" name="text_{{ word.id }}" value="{{ word.text }}">
        </div>
        {% endfor %}
        <div class="buttons">
          <!-- Simplified to one commit button -->
          <button type="submit" name="action" value="commit" class="approve-btn">Commit & Next</button>
        </div>
      </form>
      <a href="{{ url_for('main.index') }}" class="back-link">← Back to List</a>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // --- UI Elements ---
        const mainForm = document.getElementById('main-form');
        const overlay = document.getElementById('bbox-overlay');
        const statusIndicator = document.getElementById('autosave-status');
        const offsetXInput = document.getElementById('offsetX');
        const offsetYInput = document.getElementById('offsetY');
        const rotationInput = document.getElementById('rotation');
        const scaleInput = document.getElementById('scale');
        const rotateSlider = document.getElementById('rotate-slider');
        const rotateNumberInput = document.getElementById('rotate-input');
        const scaleSlider = document.getElementById('scale-slider');
        const scaleNumberInput = document.getElementById('scale-input');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const revertBtn = document.getElementById('revert-btn');
        const translateXInput = document.getElementById('translateX-input');
        const translateYInput = document.getElementById('translateY-input');

        // --- State Management ---
        let isDragging = false;
        let startX, startY;
        let debounceTimer;
        let history = [];
        let historyIndex = -1;
        let isApplyingHistory = false;

        // Re-pasting the unchanged functions here for completeness
        function captureState() {
          const state = { offsetX: parseFloat(offsetXInput.value), offsetY: parseFloat(offsetYInput.value), rotation: parseFloat(rotationInput.value), scale: parseFloat(scaleInput.value), texts: {} };
          mainForm.querySelectorAll('input[type="text"]').forEach(input => { state.texts[input.name] = input.value; });
          return state;
        }

        function applyState(state) {
          isApplyingHistory = true;
          offsetXInput.value = state.offsetX;
          offsetYInput.value = state.offsetY;
          rotationInput.value = state.rotation;
          scaleInput.value = state.scale;
          translateXInput.value = state.offsetX.toFixed(0);
          translateYInput.value = state.offsetY.toFixed(0);
          rotateSlider.value = state.rotation;
          rotateNumberInput.value = state.rotation.toFixed(2);
          scaleSlider.value = state.scale;
          scaleNumberInput.value = state.scale.toFixed(2);
          overlay.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) rotate(${state.rotation}deg) scale(${state.scale})`;
          for (const [name, value] of Object.entries(state.texts)) {
            const input = mainForm.querySelector(`input[name="${name}"]`);
            if (input) input.value = value;
          }
          setTimeout(() => { isApplyingHistory = false; }, 50);
        }

        function pushStateToHistory() {
          if (isApplyingHistory) return;
          const newState = captureState();
          if (historyIndex > -1 && JSON.stringify(newState) === JSON.stringify(history[historyIndex])) { return; }
          if (historyIndex < history.length - 1) { history.splice(historyIndex + 1); }
          history.push(newState);
          historyIndex = history.length - 1;
          updateUndoRedoButtons();
        }
        function updateUndoRedoButtons() {
          undoBtn.disabled = historyIndex <= 0;
          redoBtn.disabled = historyIndex >= history.length - 1;
        }

        undoBtn.addEventListener('click', () => {
          if (historyIndex > 0) { historyIndex--; applyState(history[historyIndex]); updateUndoRedoButtons(); debouncedAutoSave(); }
        });
        redoBtn.addEventListener('click', () => {
          if (historyIndex < history.length - 1) { historyIndex++; applyState(history[historyIndex]); updateUndoRedoButtons(); debouncedAutoSave(); }
        });

        // THIS IS THE MAINLY UPDATED FUNCTION
        revertBtn.addEventListener('click', async () => {
          if (!confirm('Are you sure you want to revert to the original source file?\n\nThis will overwrite your current draft.')) {
            return;
          }

          try {
            statusIndicator.textContent = 'Reverting...';
            statusIndicator.className = 'status-progress';

            // 1. Fetch the pristine data from the new server endpoint
            const response = await fetch("{{ url_for('api.get_source_data', json_filename=json_filename) }}");
            if (!response.ok) {
              throw new Error(`Could not fetch source data. Server status: ${response.status}`);
            }
            const sourceData = await response.json();

            // 2. CRITICAL: Update the hidden textarea that holds the base for transformations
            const baseDataTextarea = document.querySelector('textarea[name="json_data"]');
            baseDataTextarea.value = JSON.stringify(sourceData);

            // 3. Construct a "clean slate" state object from the source data
            const revertedState = {
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              scale: 1.0,
              texts: {}
            };

            sourceData.lines.forEach((line, line_idx) => {
              line.words.forEach((word, word_idx) => {
                const wordId = `${line_idx}_${word_idx}`;
                revertedState.texts[`text_${wordId}`] = word.text;
              });
            });

            // 4. Apply the clean state to the UI
            applyState(revertedState);

            // 5. Reset the undo/redo history with this clean state as the new beginning
            history = [revertedState];
            historyIndex = 0;
            updateUndoRedoButtons();

            // 6. Trigger an auto-save to overwrite the draft on the server
            autoSaveState(); // Use direct call, not debounced, for immediate action

          } catch (error) {
            console.error('Revert failed:', error);
            alert('Failed to revert to original. Please check the console for errors.');
            statusIndicator.textContent = 'Revert Failed!';
            statusIndicator.className = 'status-error';
          }
        });

        // --- Auto-Save Logic ---
        const debouncedAutoSave = debounce(() => {
          pushStateToHistory();
          autoSaveState();
        }, 1000);


        async function autoSaveState() {
          statusIndicator.textContent = 'Saving...';
          statusIndicator.className = 'status-progress';
          const formData = new FormData(mainForm);
          try {
            const response = await fetch("{{ url_for('api.autosave', json_filename=json_filename) }}", { method: 'POST', body: formData });
            if (response.ok) {
              statusIndicator.textContent = 'Draft Saved ✓'; statusIndicator.className = 'status-validated';
            } else { throw new Error(`Server responded with status: ${response.status}`); }
          } catch (error) { console.error('Autosave failed:', error); statusIndicator.textContent = 'Save Failed!'; statusIndicator.className = 'status-error'; }
        }
        function debounce(func, delay) {
          return function (...args) { clearTimeout(debounceTimer); debounceTimer = setTimeout(() => { func.apply(this, args); }, delay); };
        }
        function updateVisualTransformFromControls() {
          overlay.style.transform = `translate(${offsetXInput.value}px, ${offsetYInput.value}px) rotate(${rotationInput.value}deg) scale(${scaleInput.value})`;
        }
        overlay.addEventListener('mousedown', (e) => {
          isDragging = true; const baseOffsetX = parseFloat(offsetXInput.value); const baseOffsetY = parseFloat(offsetYInput.value);
          startX = e.clientX - baseOffsetX; startY = e.clientY - baseOffsetY; overlay.classList.add('dragging'); e.preventDefault();
        });
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return; const newOffsetX = e.clientX - startX; const newOffsetY = e.clientY - startY;
          offsetXInput.value = newOffsetX; offsetYInput.value = newOffsetY;
          translateXInput.value = Math.round(newOffsetX); translateYInput.value = Math.round(newOffsetY);
          updateVisualTransformFromControls();
        });
        document.addEventListener('mouseup', () => { if (!isDragging) return; isDragging = false; overlay.classList.remove('dragging'); debouncedAutoSave(); });
        mainForm.querySelectorAll('input[type="text"]').forEach(input => { input.addEventListener('input', debouncedAutoSave); });
        rotateSlider.addEventListener('input', () => { rotationInput.value = rotateSlider.value; rotateNumberInput.value = parseFloat(rotateSlider.value).toFixed(2); updateVisualTransformFromControls(); });
        scaleSlider.addEventListener('input', () => { scaleInput.value = scaleSlider.value; scaleNumberInput.value = parseFloat(scaleSlider.value).toFixed(2); updateVisualTransformFromControls(); });
        rotateNumberInput.addEventListener('change', () => { rotateSlider.value = rotateNumberInput.value; rotationInput.value = rotateNumberInput.value; updateVisualTransformFromControls(); debouncedAutoSave(); });
        scaleNumberInput.addEventListener('change', () => { scaleSlider.value = scaleNumberInput.value; scaleInput.value = scaleNumberInput.value; updateVisualTransformFromControls(); debouncedAutoSave(); });
        translateXInput.addEventListener('change', () => { offsetXInput.value = translateXInput.value; updateVisualTransformFromControls(); debouncedAutoSave(); });
        translateYInput.addEventListener('change', () => { offsetYInput.value = translateYInput.value; updateVisualTransformFromControls(); debouncedAutoSave(); });
        function initialize() {
          overlay.style.transformOrigin = 'center center'; applyState(captureState()); pushStateToHistory(); updateUndoRedoButtons();
        }
        initialize();
      });
    </script>
</body>

</html>
--- ./validator_app/routes/api.py ---
# validator_app/routes/api.py
import os
import json
from flask import Blueprint, request, redirect, url_for, jsonify, abort, current_app
from validator_app.utils import (
    apply_transformations_to_data,
    get_json_files,
    get_file_status,
)

api_bp = Blueprint("api", __name__)


@api_bp.route("/autosave/<string:json_filename>", methods=["POST"])
def autosave(json_filename):
    """Auto-saves the current state to the in_progress directory."""
    transformed_data = apply_transformations_to_data(request.form)
    save_path = os.path.join(current_app.config["IN_PROGRESS_DATA_DIR"], json_filename)
    with open(save_path, "w") as f:
        json.dump(transformed_data, f, indent=2)
    return jsonify({"status": "ok", "message": "Draft saved."})


@api_bp.route("/commit/<string:json_filename>", methods=["POST"])
def commit(json_filename):
    """Commits the final changes to the validated directory."""
    config = current_app.config
    transformed_data = apply_transformations_to_data(request.form)
    transformed_data["validated"] = True

    validated_path = os.path.join(config["VALIDATED_DATA_DIR"], json_filename)
    with open(validated_path, "w") as f:
        json.dump(transformed_data, f, indent=2)

    in_progress_path = os.path.join(config["IN_PROGRESS_DATA_DIR"], json_filename)
    if os.path.exists(in_progress_path):
        os.remove(in_progress_path)

    all_files = get_json_files()
    current_index = all_files.index(json_filename) if json_filename in all_files else -1
    for i in range(current_index + 1, len(all_files)):
        if get_file_status(all_files[i]) != "validated":
            # Use blueprint name in url_for: 'main.validate'
            return redirect(url_for("main.validate", json_filename=all_files[i]))

    return redirect(url_for("main.index"))


@api_bp.route("/get_source_data/<string:json_filename>")
def get_source_data(json_filename):
    """Endpoint to fetch the raw, unmodified JSON data."""
    source_path = os.path.join(current_app.config["SOURCE_DATA_DIR"], json_filename)
    if not os.path.exists(source_path):
        abort(404, f"Source file '{json_filename}' not found.")
    with open(source_path, "r") as f:
        data = json.load(f)
    return jsonify(data)

--- ./validator_app/routes/main.py ---
# validator_app/routes/main.py
import json
from flask import Blueprint, render_template, abort
from validator_app.utils import get_json_files, get_file_status, load_data

main_bp = Blueprint("main", __name__)


@main_bp.route("/")
def index():
    """Homepage: shows a list of files and their status."""
    files = get_json_files()
    file_statuses = [{"filename": f, "status": get_file_status(f)} for f in files]
    return render_template("index.html", files=file_statuses)


@main_bp.route("/validate/<string:json_filename>")
def validate(json_filename):
    data = load_data(json_filename)
    if not data:
        abort(404, "JSON file not found.")

    annotations = []
    word_counter = 0
    for line_idx, line in enumerate(data.get("lines", [])):
        for word_idx, word in enumerate(line.get("words", [])):
            word_info = word.copy()
            word_id = f"{line_idx}_{word_idx}"
            word_info["id"] = word_id
            word_info["display_id"] = word_counter + 1
            word["id"] = word_id
            annotations.append(word_info)
            word_counter += 1

    return render_template(
        "validate.html",
        json_filename=json_filename,
        image_filename=data["image_source"],
        image_dimensions=data.get("image_dimensions", {}),
        annotations=annotations,
        json_data_string=json.dumps(data),
    )

--- ./app.py ---
import os
import json
import math
from flask import Flask, render_template, request, redirect, url_for, abort, jsonify
from PIL import Image

# --- Configuration ---
app = Flask(__name__)
SOURCE_DATA_DIR = 'data_source'
IN_PROGRESS_DATA_DIR = 'data_in_progress'
VALIDATED_DATA_DIR = 'data_validated'
IMAGE_DIR = os.path.join('static', 'images')

# Ensure all directories exist on startup
os.makedirs(SOURCE_DATA_DIR, exist_ok=True)
os.makedirs(IN_PROGRESS_DATA_DIR, exist_ok=True)
os.makedirs(VALIDATED_DATA_DIR, exist_ok=True)


# --- Helper Functions ---

def get_json_files():
    """Get a sorted list of all unique JSON files from all data directories."""
    files = set(os.listdir(SOURCE_DATA_DIR))
    files.update(os.listdir(IN_PROGRESS_DATA_DIR))
    files.update(os.listdir(VALIDATED_DATA_DIR))
    return sorted([f for f in files if f.endswith('.json')])

def get_file_status(json_filename):
    """Check the status of a file: 'validated', 'in_progress', or 'source'."""
    if os.path.exists(os.path.join(VALIDATED_DATA_DIR, json_filename)):
        return 'validated'
    if os.path.exists(os.path.join(IN_PROGRESS_DATA_DIR, json_filename)):
        return 'in_progress'
    return 'source'

def load_data(json_filename):
    """
    Load data with 3-tier priority: In Progress > Validated > Source.
    """
    in_progress_path = os.path.join(IN_PROGRESS_DATA_DIR, json_filename)
    validated_path = os.path.join(VALIDATED_DATA_DIR, json_filename)
    source_path = os.path.join(SOURCE_DATA_DIR, json_filename)

    load_path = None
    if os.path.exists(in_progress_path):
        load_path = in_progress_path
    elif os.path.exists(validated_path):
        load_path = validated_path
    elif os.path.exists(source_path):
        load_path = source_path

    if not load_path:
        return None

    with open(load_path, 'r') as f:
        return json.load(f)

def apply_transformations_to_data(form_data):
    """
    Helper to apply form changes to a data object. Reusable for autosave and commit.
    """
    # Create a deep copy to avoid modifying the original data object in memory
    data = json.loads(form_data['json_data'])

    # Get transformation parameters
    offsetX = float(form_data.get('offsetX', 0))
    offsetY = float(form_data.get('offsetY', 0))
    rotation_deg = float(form_data.get('rotation', 0))
    scale = float(form_data.get('scale', 1.0))

    is_transformed = (offsetX != 0 or offsetY != 0 or rotation_deg != 0 or scale != 1.0)

    if is_transformed:
        img_dims = data.get('image_dimensions', {})
        cx = img_dims.get('width', 0) / 2
        cy = img_dims.get('height', 0) / 2
        rotation_rad = math.radians(rotation_deg)
        cos_rad = math.cos(rotation_rad)
        sin_rad = math.sin(rotation_rad)

    # This loop structure assumes word IDs are in 'lineidx_wordidx' format
    all_words = {}
    for line in data.get('lines', []):
        for word in line.get('words', []):
             all_words[word['id']] = word

    for key, value in form_data.items():
        if key.startswith('text_'):
            word_id = key.replace('text_', '')
            if word_id in all_words:
                all_words[word_id]['text'] = value

    if is_transformed:
        for word in all_words.values():
            if 'bounding_box' not in word: continue
            bbox = word['bounding_box']
            corners = [
                (bbox['x_min'], bbox['y_min']), (bbox['x_max'], bbox['y_min']),
                (bbox['x_max'], bbox['y_max']), (bbox['x_min'], bbox['y_max']),
            ]
            transformed_corners = []
            for x, y in corners:
                x_scaled = cx + (x - cx) * scale
                y_scaled = cy + (y - cy) * scale
                x_rot = cx + (x_scaled - cx) * cos_rad - (y_scaled - cy) * sin_rad
                y_rot = cy + (x_scaled - cx) * sin_rad + (y_scaled - cy) * cos_rad
                transformed_corners.append((x_rot + offsetX, y_rot + offsetY))

            word['bounding_box'] = {
                'x_min': int(round(min(p[0] for p in transformed_corners))),
                'y_min': int(round(min(p[1] for p in transformed_corners))),
                'x_max': int(round(max(p[0] for p in transformed_corners))),
                'y_max': int(round(max(p[1] for p in transformed_corners))),
            }

    return data


# --- Routes ---

@app.route('/')
def index():
    """Homepage: shows a list of files and their status."""
    files = get_json_files()
    file_statuses = [{'filename': f, 'status': get_file_status(f)} for f in files]
    return render_template('index.html', files=file_statuses)

@app.route('/validate/<string:json_filename>')
def validate(json_filename):
    data = load_data(json_filename)
    if not data:
        abort(404, "JSON file not found.")

    # Flatten words and add unique IDs
    annotations = []
    word_counter = 0
    for line_idx, line in enumerate(data.get('lines', [])):
        for word_idx, word in enumerate(line.get('words', [])):
            word_info = word.copy()
            word_info['id'] = f"{line_idx}_{word_idx}"
            word_info['display_id'] = word_counter + 1
            # Update the original data object with this ID for consistency
            word['id'] = word_info['id']
            annotations.append(word_info)
            word_counter += 1

    return render_template(
        'validate.html',
        json_filename=json_filename,
        image_filename=data['image_source'],
        image_dimensions=data.get('image_dimensions', {}),
        annotations=annotations,
        # Pass the full data object as a JSON string for the frontend to use
        json_data_string=json.dumps(data)
    )

@app.route('/autosave/<string:json_filename>', methods=['POST'])
def autosave(json_filename):
    """Auto-saves the current state to the in_progress directory."""
    transformed_data = apply_transformations_to_data(request.form)

    save_path = os.path.join(IN_PROGRESS_DATA_DIR, json_filename)
    with open(save_path, 'w') as f:
        json.dump(transformed_data, f, indent=2)

    return jsonify({'status': 'ok', 'message': 'Draft saved.'})

@app.route('/commit/<string:json_filename>', methods=['POST'])
def commit(json_filename):
    """Commits the final changes to the validated directory."""
    transformed_data = apply_transformations_to_data(request.form)
    transformed_data['validated'] = True

    # Save to validated directory
    validated_path = os.path.join(VALIDATED_DATA_DIR, json_filename)
    with open(validated_path, 'w') as f:
        json.dump(transformed_data, f, indent=2)

    # Remove from in_progress directory
    in_progress_path = os.path.join(IN_PROGRESS_DATA_DIR, json_filename)
    if os.path.exists(in_progress_path):
        os.remove(in_progress_path)

    # Redirect to the next unvalidated/in-progress file
    all_files = get_json_files()
    current_index = all_files.index(json_filename) if json_filename in all_files else -1

    for i in range(current_index + 1, len(all_files)):
        if get_file_status(all_files[i]) != 'validated':
            return redirect(url_for('validate', json_filename=all_files[i]))

    return redirect(url_for('index'))

# --- NEW ROUTE ---
@app.route('/get_source_data/<string:json_filename>')
def get_source_data(json_filename):
    """
    Endpoint to fetch the raw, unmodified JSON data from the source directory.
    """
    source_path = os.path.join(SOURCE_DATA_DIR, json_filename)

    if not os.path.exists(source_path):
        abort(404, f"Source file '{json_filename}' not found.")

    with open(source_path, 'r') as f:
        data = json.load(f)

    return jsonify(data)

if __name__ == '__main__':
    app.run(debug=True)

